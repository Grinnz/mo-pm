=head1 Overview

This is the design document for the L<Mo> module.

It is intended to help people understand the thinking behind Mo.

Like Mo, it is a work in progress. Nothing here is in stone. Everything is up
for discussion. This document just explains the current understanding, so
you'll know where to start.

=head1 Design Goals

Mo has the following design goals. These goals have to be balanced against
each other.

=over

=item Provide usable OO for Perl modules.

This includes I<at least> the following. The current implementation contains a
bit more than this, but that is due to the other design goals.

=over

=item Single Inheritance

Mo should provide a mechanism for inheritance. At least single inheritance.

=item Object Construction

Mo needs to provide a C<new()> object constructor. It should take a set of
name/value pairs and return a new object reference, blessed into the class'
package name.

=item Attribute Declaration

Mo needs to provide a way to declare attribute accessing methods. They need to
be able to set and get values.

=back

=item Be minimal

Only add features if they are considered very desirable B<and> can be
implemented in a very small amount of code.

=item Be useful

Mo wants to be the first module that Perl programmers reach for when they need
simple OO. To that end, it needs to support extremely useful and common
idioms, even if they are not strictly minimal.

=item Be fast

Mo should be about as fast as if you rolled your own OO. It should be fast at
both startup (compile) time and at run time. It should especially strive to
have fast accessors. Speed optimizations should be simple and minimal.

=item Be embeddable

There may be situations where you want to inline Mo into your code, For this
reason, Mo will try to be in one minimal, pure Perl file, with no comments or
documentation.

=item Easy upgrade/downgrade path with Moo

L<Moose> has become the accepted style of OO in perl. Mo will attempt to not
do the things it does in an incompatible style to the C<Moose> family.
    
This is not to say that all Mo code can be switched to Moo, or vice versa.
This is to say that you should be able to find a style of coding using the
full capabilities of Mo, that you can switch to Moo (or L<Mouse> or L<Moose>),
if you want to.

This is a difficult design goal, and might sometimes lose out to the other
goals. However, this document will attempt to explain all the decisions.

=back

=head1 Current Status

This section will go into detail on all the current aspects of Mo, why
decisions were made and any known concerns being thought about.

=over

=item Inheritance

Mo uses C<extends> to name its parents.

This means that it supports multiple inheritance. This is probably a bad idea,
for a few reasons. MI is generally frowned upon in Perl. It has problems that
are better solved by roles. It also makes the BUILD call sequence much more
difficult, which makes Moose compatibility hard. For this reason, we should
remove MI as a Mo feature. Moo can be used for that.

=item Construction

Mo uses a C<new> method for construction.

It makes use of the BUILD method, for construction extension. Since it does
this, it is only proper to call the SUPER::BUILD methods in the same order as
the Moose family. Mo does this. This is not the minimal method of
construction, but it is considered useful to have, so we do it. Hopefully this
is not too big of a performance penalty. Speed optimations should be
considered.

=item Accessors

Mo uses C<has> for generating accessors. Like Moose, it takes a name and a
list of option/value pairs.

All options are silently ignored, except C<default> and C<build>. These were
implemented because they are almost always needed, and the implementation is
minimal. They are always lazy (like 'lazy => 1' in Moose). Since Mo will
likely be rare in a precompile environment like in mod_perl, this is
considered a speed gain. It also happens to be the more minimal way to code
this.

If neither C<default> nor C<build> is requested, has will return a
getter/setter that is optimized for speed.

All accessors are 'rw'. That means they are getter+setter methods. Since
C<has> ignores the C<is> option, there is no special case for a read only
accessor. The accessor (in 'get' mode) checks C<@_> for zero. This check could
potentially be avoided if 'ro' were honored, but if one expects a 'ro'
accessor, they expect it to fail on set. Given that, you would still need to
check for zero args, so no speed gain is possible.

=item No runtime checks

Mo will not check or validate its usage. It is so minimal, that it will leave
this up to the code author. Run time checks don't offer any gain when the
usage is already correct. In a dynamic language like Perl, they only serve to
make code slower. Plus, runtime checks would bloat the Mo code. Where would
you draw the line? The best option is to leave them out, document things well,
and let people write tests for their code, if they really need to. Upgrading
from Mo is another alternative.

=item Size matters

Mo.pm is currently golfed, compressed and unreadable by mere mortals. It has
no comments or pod. The documentation is in Mo.pod and the comments are all in
here. This makes Mo.pm a little black box of code that you can use anywhere.

When we hack on Mo.pm we run it through perltidy and it loks great. When we
are done we run ./script/compress.pl on it and it turns into 2 lines.

It needs to be 2 lines because Module::Install barfs on parsing out the
VERSION otherwise. Either Module::Install should be fixed or we should stop
using it for this.

=item strict and warnings

We turn on strict and warnings for the user of Mo because it is really easy
and offers great value. Also, all the other Moose family does it.


